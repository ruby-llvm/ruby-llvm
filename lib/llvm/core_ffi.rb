# Generated by ffi_gen. Please do not change this file by hand.

require 'ffi'

module LLVM::C
  extend FFI::Library
  ffi_lib 'LLVM-3.0'

  # === Options:

  #
  # @return [Array of Symbols]
  def self.attribute_enum
    []
  end
  enum :attribute, [

  ]

  # === Options:
  # :ret::
  #   Terminator Instructions
  # :br::
  #   
  # :switch::
  #   
  # :indirect_br::
  #   
  # :invoke::
  #   
  # :unreachable::
  #   removed 6 due to API changes
  # :add::
  #   Standard Binary Operators
  # :f_add::
  #   
  # :sub::
  #   
  # :f_sub::
  #   
  # :mul::
  #   
  # :f_mul::
  #   
  # :u_div::
  #   
  # :s_div::
  #   
  # :f_div::
  #   
  # :u_rem::
  #   
  # :s_rem::
  #   
  # :f_rem::
  #   
  # :shl::
  #   Logical Operators
  # :l_shr::
  #   
  # :a_shr::
  #   
  # :and::
  #   
  # :or::
  #   
  # :xor::
  #   
  # :alloca::
  #   Memory Operators
  # :load::
  #   
  # :store::
  #   
  # :get_element_ptr::
  #   
  # :trunc::
  #   Cast Operators
  # :z_ext::
  #   
  # :s_ext::
  #   
  # :fp_to_ui::
  #   
  # :fp_to_si::
  #   
  # :ui_to_fp::
  #   
  # :si_to_fp::
  #   
  # :fp_trunc::
  #   
  # :fp_ext::
  #   
  # :ptr_to_int::
  #   
  # :int_to_ptr::
  #   
  # :bit_cast::
  #   
  # :i_cmp::
  #   Other Operators
  # :f_cmp::
  #   
  # :phi::
  #   
  # :call::
  #   
  # :select::
  #   
  # :user_op1::
  #   
  # :user_op2::
  #   
  # :va_arg::
  #   
  # :extract_element::
  #   
  # :insert_element::
  #   
  # :shuffle_vector::
  #   
  # :extract_value::
  #   
  # :insert_value::
  #   
  # :fence::
  #   Atomic operators
  # :atomic_cmp_xchg::
  #   
  # :atomic_rmw::
  #   
  # :resume::
  #   Exception Handling Operators
  # :landing_pad::
  #   
  # :unwind::
  #   
  #
  # @return [Array of Symbols]
  def self.opcode_enum
    [:ret, :br, :switch, :indirect_br, :invoke, :unreachable, :add, :f_add, :sub, :f_sub, :mul, :f_mul, :u_div, :s_div, :f_div, :u_rem, :s_rem, :f_rem, :shl, :l_shr, :a_shr, :and, :or, :xor, :alloca, :load, :store, :get_element_ptr, :trunc, :z_ext, :s_ext, :fp_to_ui, :fp_to_si, :ui_to_fp, :si_to_fp, :fp_trunc, :fp_ext, :ptr_to_int, :int_to_ptr, :bit_cast, :i_cmp, :f_cmp, :phi, :call, :select, :user_op1, :user_op2, :va_arg, :extract_element, :insert_element, :shuffle_vector, :extract_value, :insert_value, :fence, :atomic_cmp_xchg, :atomic_rmw, :resume, :landing_pad, :unwind]
  end
  enum :opcode, [
    :ret, 1,
    :br, 2,
    :switch, 3,
    :indirect_br, 4,
    :invoke, 5,
    :unreachable, 7,
    :add, 8,
    :f_add, 9,
    :sub, 10,
    :f_sub, 11,
    :mul, 12,
    :f_mul, 13,
    :u_div, 14,
    :s_div, 15,
    :f_div, 16,
    :u_rem, 17,
    :s_rem, 18,
    :f_rem, 19,
    :shl, 20,
    :l_shr, 21,
    :a_shr, 22,
    :and, 23,
    :or, 24,
    :xor, 25,
    :alloca, 26,
    :load, 27,
    :store, 28,
    :get_element_ptr, 29,
    :trunc, 30,
    :z_ext, 31,
    :s_ext, 32,
    :fp_to_ui, 33,
    :fp_to_si, 34,
    :ui_to_fp, 35,
    :si_to_fp, 36,
    :fp_trunc, 37,
    :fp_ext, 38,
    :ptr_to_int, 39,
    :int_to_ptr, 40,
    :bit_cast, 41,
    :i_cmp, 42,
    :f_cmp, 43,
    :phi, 44,
    :call, 45,
    :select, 46,
    :user_op1, 47,
    :user_op2, 48,
    :va_arg, 49,
    :extract_element, 50,
    :insert_element, 51,
    :shuffle_vector, 52,
    :extract_value, 53,
    :insert_value, 54,
    :fence, 55,
    :atomic_cmp_xchg, 56,
    :atomic_rmw, 57,
    :resume, 58,
    :landing_pad, 59,
    :unwind, 60
  ]

  # === Options:
  # :void::
  #   
  # :float::
  #   < type with no size
  # :double::
  #   < 32 bit floating point type
  # :x86_fp80::
  #   < 64 bit floating point type
  # :fp128::
  #   < 80 bit floating point type (X87)
  # :ppc_fp128::
  #   < 128 bit floating point type (112-bit mantissa)
  # :label::
  #   < 128 bit floating point type (two 64-bits)
  # :integer::
  #   < Labels
  # :function::
  #   < Arbitrary bit width integers
  # :struct::
  #   < Functions
  # :array::
  #   < Structures
  # :pointer::
  #   < Arrays
  # :vector::
  #   < Pointers
  # :metadata::
  #   < SIMD 'packed' format, or other vector type
  # :x86_mmx::
  #   < Metadata
  #
  # @return [Array of Symbols]
  def self.type_kind_enum
    [:void, :float, :double, :x86_fp80, :fp128, :ppc_fp128, :label, :integer, :function, :struct, :array, :pointer, :vector, :metadata, :x86_mmx]
  end
  enum :type_kind, [
    :void,
    :float,
    :double,
    :x86_fp80,
    :fp128,
    :ppc_fp128,
    :label,
    :integer,
    :function,
    :struct,
    :array,
    :pointer,
    :vector,
    :metadata,
    :x86_mmx
  ]

  # === Options:
  # :external::
  #   
  # :available_externally::
  #   < Externally visible function
  # :link_once_any::
  #   
  # :link_once_odr::
  #   < Keep one copy of function when linking (inline)
  # :weak_any::
  #   < Same, but only replaced by something
  #                               equivalent.
  # :weak_odr::
  #   < Keep one copy of function when linking (weak)
  # :appending::
  #   < Same, but only replaced by something
  #                               equivalent.
  # :internal::
  #   < Special purpose, only applies to global arrays
  # :private::
  #   < Rename collisions when linking (static
  #                                  functions)
  # :dll_import::
  #   < Like Internal, but omit from symbol table
  # :dll_export::
  #   < Function to be imported from DLL
  # :external_weak::
  #   < Function to be accessible from DLL
  # :ghost::
  #   < ExternalWeak linkage description
  # :common::
  #   < Obsolete
  # :linker_private::
  #   < Tentative definitions
  # :linker_private_weak::
  #   < Like Private, but linker removes.
  # :linker_private_weak_def_auto::
  #   < Like LinkerPrivate, but is weak.
  #
  # @return [Array of Symbols]
  def self.linkage_enum
    [:external, :available_externally, :link_once_any, :link_once_odr, :weak_any, :weak_odr, :appending, :internal, :private, :dll_import, :dll_export, :external_weak, :ghost, :common, :linker_private, :linker_private_weak, :linker_private_weak_def_auto]
  end
  enum :linkage, [
    :external,
    :available_externally,
    :link_once_any,
    :link_once_odr,
    :weak_any,
    :weak_odr,
    :appending,
    :internal,
    :private,
    :dll_import,
    :dll_export,
    :external_weak,
    :ghost,
    :common,
    :linker_private,
    :linker_private_weak,
    :linker_private_weak_def_auto
  ]

  # === Options:
  # :default::
  #   
  # :hidden::
  #   < The GV is visible
  # :protected::
  #   < The GV is hidden
  #
  # @return [Array of Symbols]
  def self.visibility_enum
    [:default, :hidden, :protected]
  end
  enum :visibility, [
    :default,
    :hidden,
    :protected
  ]

  # === Options:
  # :c::
  #   
  # :fast::
  #   
  # :cold::
  #   
  # :x86_stdcall::
  #   
  # :x86_fastcall::
  #   
  #
  # @return [Array of Symbols]
  def self.call_conv_enum
    [:c, :fast, :cold, :x86_stdcall, :x86_fastcall]
  end
  enum :call_conv, [
    :c, 0,
    :fast, 8,
    :cold, 9,
    :x86_stdcall, 64,
    :x86_fastcall, 65
  ]

  # === Options:
  # :eq::
  #   
  # :ne::
  #   < equal
  # :ugt::
  #   < not equal
  # :uge::
  #   < unsigned greater than
  # :ult::
  #   < unsigned greater or equal
  # :ule::
  #   < unsigned less than
  # :sgt::
  #   < unsigned less or equal
  # :sge::
  #   < signed greater than
  # :slt::
  #   < signed greater or equal
  # :sle::
  #   < signed less than
  #
  # @return [Array of Symbols]
  def self.int_predicate_enum
    [:eq, :ne, :ugt, :uge, :ult, :ule, :sgt, :sge, :slt, :sle]
  end
  enum :int_predicate, [
    :eq, 32,
    :ne,
    :ugt,
    :uge,
    :ult,
    :ule,
    :sgt,
    :sge,
    :slt,
    :sle
  ]

  # === Options:
  # :predicate_false::
  #   
  # :oeq::
  #   < Always false (always folded)
  # :ogt::
  #   < True if ordered and equal
  # :oge::
  #   < True if ordered and greater than
  # :olt::
  #   < True if ordered and greater than or equal
  # :ole::
  #   < True if ordered and less than
  # :one::
  #   < True if ordered and less than or equal
  # :ord::
  #   < True if ordered and operands are unequal
  # :uno::
  #   < True if ordered (no nans)
  # :ueq::
  #   < True if unordered: isnan(X) | isnan(Y)
  # :ugt::
  #   < True if unordered or equal
  # :uge::
  #   < True if unordered or greater than
  # :ult::
  #   < True if unordered, greater than, or equal
  # :ule::
  #   < True if unordered or less than
  # :une::
  #   < True if unordered, less than, or equal
  # :predicate_true::
  #   < True if unordered or not equal
  #
  # @return [Array of Symbols]
  def self.real_predicate_enum
    [:predicate_false, :oeq, :ogt, :oge, :olt, :ole, :one, :ord, :uno, :ueq, :ugt, :uge, :ult, :ule, :une, :predicate_true]
  end
  enum :real_predicate, [
    :predicate_false,
    :oeq,
    :ogt,
    :oge,
    :olt,
    :ole,
    :one,
    :ord,
    :uno,
    :ueq,
    :ugt,
    :uge,
    :ult,
    :ule,
    :une,
    :predicate_true
  ]

  # === Options:
  # :catch::
  #   
  # :filter::
  #   < A catch clause  
  #
  # @return [Array of Symbols]
  def self.landing_pad_clause_ty_enum
    [:catch, :filter]
  end
  enum :landing_pad_clause_ty, [
    :catch,
    :filter
  ]

  # @method initialize_core(r)
  # @param [FFI::Pointer of PassRegistryRef] r 
  # @return [nil] 
  # @scope class
  attach_function :initialize_core, :LLVMInitializeCore, [:pointer], :void

  # ===-- Error handling ----------------------------------------------------===
  # 
  # @method dispose_message(message)
  # @param [String] message 
  # @return [nil] 
  # @scope class
  attach_function :dispose_message, :LLVMDisposeMessage, [:string], :void

  # Create and destroy contexts.
  # 
  # @method context_create()
  # @return [FFI::Pointer of ContextRef] 
  # @scope class
  attach_function :context_create, :LLVMContextCreate, [], :pointer

  # @method get_global_context()
  # @return [FFI::Pointer of ContextRef] 
  # @scope class
  attach_function :get_global_context, :LLVMGetGlobalContext, [], :pointer

  # @method context_dispose(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [nil] 
  # @scope class
  attach_function :context_dispose, :LLVMContextDispose, [:pointer], :void

  # @method get_md_kind_id_in_context(c, name, s_len)
  # @param [FFI::Pointer of ContextRef] c 
  # @param [String] name 
  # @param [Integer] s_len 
  # @return [Integer] 
  # @scope class
  attach_function :get_md_kind_id_in_context, :LLVMGetMDKindIDInContext, [:pointer, :string, :uint], :uint

  # @method get_md_kind_id(name, s_len)
  # @param [String] name 
  # @param [Integer] s_len 
  # @return [Integer] 
  # @scope class
  attach_function :get_md_kind_id, :LLVMGetMDKindID, [:string, :uint], :uint

  # See llvm::Module::Module.
  # 
  # @method module_create_with_name(module_id)
  # @param [String] module_id 
  # @return [FFI::Pointer of ModuleRef] 
  # @scope class
  attach_function :module_create_with_name, :LLVMModuleCreateWithName, [:string], :pointer

  # @method module_create_with_name_in_context(module_id, c)
  # @param [String] module_id 
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of ModuleRef] 
  # @scope class
  attach_function :module_create_with_name_in_context, :LLVMModuleCreateWithNameInContext, [:string, :pointer], :pointer

  # See llvm::Module::~Module.
  # 
  # @method dispose_module(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [nil] 
  # @scope class
  attach_function :dispose_module, :LLVMDisposeModule, [:pointer], :void

  # Data layout. See Module::getDataLayout.
  # 
  # @method get_data_layout(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [String] 
  # @scope class
  attach_function :get_data_layout, :LLVMGetDataLayout, [:pointer], :string

  # @method set_data_layout(m, triple)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [String] triple 
  # @return [nil] 
  # @scope class
  attach_function :set_data_layout, :LLVMSetDataLayout, [:pointer, :string], :void

  # Target triple. See Module::getTargetTriple.
  # 
  # @method get_target(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [String] 
  # @scope class
  attach_function :get_target, :LLVMGetTarget, [:pointer], :string

  # @method set_target(m, triple)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [String] triple 
  # @return [nil] 
  # @scope class
  attach_function :set_target, :LLVMSetTarget, [:pointer, :string], :void

  # See Module::dump.
  # 
  # @method dump_module(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [nil] 
  # @scope class
  attach_function :dump_module, :LLVMDumpModule, [:pointer], :void

  # See Module::setModuleInlineAsm.
  # 
  # @method set_module_inline_asm(m, asm)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [String] asm 
  # @return [nil] 
  # @scope class
  attach_function :set_module_inline_asm, :LLVMSetModuleInlineAsm, [:pointer, :string], :void

  # See Module::getContext.
  # 
  # @method get_module_context(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [FFI::Pointer of ContextRef] 
  # @scope class
  attach_function :get_module_context, :LLVMGetModuleContext, [:pointer], :pointer

  # See llvm::LLVMTypeKind::getTypeID.
  # 
  # @method get_type_kind(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [Symbol from type_kind_enum] 
  # @scope class
  attach_function :get_type_kind, :LLVMGetTypeKind, [:pointer], :type_kind

  # @method type_is_sized(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [Integer] 
  # @scope class
  attach_function :type_is_sized, :LLVMTypeIsSized, [:pointer], :int

  # See llvm::LLVMType::getContext.
  # 
  # @method get_type_context(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [FFI::Pointer of ContextRef] 
  # @scope class
  attach_function :get_type_context, :LLVMGetTypeContext, [:pointer], :pointer

  # Operations on integer types
  # 
  # @method int1_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int1_type_in_context, :LLVMInt1TypeInContext, [:pointer], :pointer

  # @method int8_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int8_type_in_context, :LLVMInt8TypeInContext, [:pointer], :pointer

  # @method int16_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int16_type_in_context, :LLVMInt16TypeInContext, [:pointer], :pointer

  # @method int32_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int32_type_in_context, :LLVMInt32TypeInContext, [:pointer], :pointer

  # @method int64_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int64_type_in_context, :LLVMInt64TypeInContext, [:pointer], :pointer

  # @method int_type_in_context(c, num_bits)
  # @param [FFI::Pointer of ContextRef] c 
  # @param [Integer] num_bits 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int_type_in_context, :LLVMIntTypeInContext, [:pointer, :uint], :pointer

  # @method int1_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int1_type, :LLVMInt1Type, [], :pointer

  # @method int8_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int8_type, :LLVMInt8Type, [], :pointer

  # @method int16_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int16_type, :LLVMInt16Type, [], :pointer

  # @method int32_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int32_type, :LLVMInt32Type, [], :pointer

  # @method int64_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int64_type, :LLVMInt64Type, [], :pointer

  # @method int_type(num_bits)
  # @param [Integer] num_bits 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :int_type, :LLVMIntType, [:uint], :pointer

  # @method get_int_type_width(integer_ty)
  # @param [FFI::Pointer of TypeRef] integer_ty 
  # @return [Integer] 
  # @scope class
  attach_function :get_int_type_width, :LLVMGetIntTypeWidth, [:pointer], :uint

  # Operations on real types
  # 
  # @method float_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :float_type_in_context, :LLVMFloatTypeInContext, [:pointer], :pointer

  # @method double_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :double_type_in_context, :LLVMDoubleTypeInContext, [:pointer], :pointer

  # @method x86fp80_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :x86fp80_type_in_context, :LLVMX86FP80TypeInContext, [:pointer], :pointer

  # @method fp128_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :fp128_type_in_context, :LLVMFP128TypeInContext, [:pointer], :pointer

  # @method ppcfp128_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :ppcfp128_type_in_context, :LLVMPPCFP128TypeInContext, [:pointer], :pointer

  # @method float_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :float_type, :LLVMFloatType, [], :pointer

  # @method double_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :double_type, :LLVMDoubleType, [], :pointer

  # @method x86fp80_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :x86fp80_type, :LLVMX86FP80Type, [], :pointer

  # @method fp128_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :fp128_type, :LLVMFP128Type, [], :pointer

  # @method ppcfp128_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :ppcfp128_type, :LLVMPPCFP128Type, [], :pointer

  # Operations on function types
  # 
  # @method function_type(return_type, param_types, param_count, is_var_arg)
  # @param [FFI::Pointer of TypeRef] return_type 
  # @param [FFI::Pointer to ] param_types 
  # @param [Integer] param_count 
  # @param [Integer] is_var_arg 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :function_type, :LLVMFunctionType, [:pointer, :pointer, :uint, :int], :pointer

  # @method is_function_var_arg(function_ty)
  # @param [FFI::Pointer of TypeRef] function_ty 
  # @return [Integer] 
  # @scope class
  attach_function :is_function_var_arg, :LLVMIsFunctionVarArg, [:pointer], :int

  # @method get_return_type(function_ty)
  # @param [FFI::Pointer of TypeRef] function_ty 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :get_return_type, :LLVMGetReturnType, [:pointer], :pointer

  # @method count_param_types(function_ty)
  # @param [FFI::Pointer of TypeRef] function_ty 
  # @return [Integer] 
  # @scope class
  attach_function :count_param_types, :LLVMCountParamTypes, [:pointer], :uint

  # @method get_param_types(function_ty, dest)
  # @param [FFI::Pointer of TypeRef] function_ty 
  # @param [FFI::Pointer to ] dest 
  # @return [nil] 
  # @scope class
  attach_function :get_param_types, :LLVMGetParamTypes, [:pointer, :pointer], :void

  # Operations on struct types
  # 
  # @method struct_type_in_context(c, element_types, element_count, packed)
  # @param [FFI::Pointer of ContextRef] c 
  # @param [FFI::Pointer to ] element_types 
  # @param [Integer] element_count 
  # @param [Integer] packed 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :struct_type_in_context, :LLVMStructTypeInContext, [:pointer, :pointer, :uint, :int], :pointer

  # @method struct_type(element_types, element_count, packed)
  # @param [FFI::Pointer to ] element_types 
  # @param [Integer] element_count 
  # @param [Integer] packed 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :struct_type, :LLVMStructType, [:pointer, :uint, :int], :pointer

  # @method struct_create_named(c, name)
  # @param [FFI::Pointer of ContextRef] c 
  # @param [String] name 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :struct_create_named, :LLVMStructCreateNamed, [:pointer, :string], :pointer

  # @method get_struct_name(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [String] 
  # @scope class
  attach_function :get_struct_name, :LLVMGetStructName, [:pointer], :string

  # @method struct_set_body(struct_ty, element_types, element_count, packed)
  # @param [FFI::Pointer of TypeRef] struct_ty 
  # @param [FFI::Pointer to ] element_types 
  # @param [Integer] element_count 
  # @param [Integer] packed 
  # @return [nil] 
  # @scope class
  attach_function :struct_set_body, :LLVMStructSetBody, [:pointer, :pointer, :uint, :int], :void

  # @method count_struct_element_types(struct_ty)
  # @param [FFI::Pointer of TypeRef] struct_ty 
  # @return [Integer] 
  # @scope class
  attach_function :count_struct_element_types, :LLVMCountStructElementTypes, [:pointer], :uint

  # @method get_struct_element_types(struct_ty, dest)
  # @param [FFI::Pointer of TypeRef] struct_ty 
  # @param [FFI::Pointer to ] dest 
  # @return [nil] 
  # @scope class
  attach_function :get_struct_element_types, :LLVMGetStructElementTypes, [:pointer, :pointer], :void

  # @method is_packed_struct(struct_ty)
  # @param [FFI::Pointer of TypeRef] struct_ty 
  # @return [Integer] 
  # @scope class
  attach_function :is_packed_struct, :LLVMIsPackedStruct, [:pointer], :int

  # @method is_opaque_struct(struct_ty)
  # @param [FFI::Pointer of TypeRef] struct_ty 
  # @return [Integer] 
  # @scope class
  attach_function :is_opaque_struct, :LLVMIsOpaqueStruct, [:pointer], :int

  # @method get_type_by_name(m, name)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [String] name 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :get_type_by_name, :LLVMGetTypeByName, [:pointer, :string], :pointer

  # Operations on array, pointer, and vector types (sequence types)
  # 
  # @method array_type(element_type, element_count)
  # @param [FFI::Pointer of TypeRef] element_type 
  # @param [Integer] element_count 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :array_type, :LLVMArrayType, [:pointer, :uint], :pointer

  # @method pointer_type(element_type, address_space)
  # @param [FFI::Pointer of TypeRef] element_type 
  # @param [Integer] address_space 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :pointer_type, :LLVMPointerType, [:pointer, :uint], :pointer

  # @method vector_type(element_type, element_count)
  # @param [FFI::Pointer of TypeRef] element_type 
  # @param [Integer] element_count 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :vector_type, :LLVMVectorType, [:pointer, :uint], :pointer

  # @method get_element_type(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :get_element_type, :LLVMGetElementType, [:pointer], :pointer

  # @method get_array_length(array_ty)
  # @param [FFI::Pointer of TypeRef] array_ty 
  # @return [Integer] 
  # @scope class
  attach_function :get_array_length, :LLVMGetArrayLength, [:pointer], :uint

  # @method get_pointer_address_space(pointer_ty)
  # @param [FFI::Pointer of TypeRef] pointer_ty 
  # @return [Integer] 
  # @scope class
  attach_function :get_pointer_address_space, :LLVMGetPointerAddressSpace, [:pointer], :uint

  # @method get_vector_size(vector_ty)
  # @param [FFI::Pointer of TypeRef] vector_ty 
  # @return [Integer] 
  # @scope class
  attach_function :get_vector_size, :LLVMGetVectorSize, [:pointer], :uint

  # Operations on other types
  # 
  # @method void_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :void_type_in_context, :LLVMVoidTypeInContext, [:pointer], :pointer

  # @method label_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :label_type_in_context, :LLVMLabelTypeInContext, [:pointer], :pointer

  # @method x86mmx_type_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :x86mmx_type_in_context, :LLVMX86MMXTypeInContext, [:pointer], :pointer

  # @method void_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :void_type, :LLVMVoidType, [], :pointer

  # @method label_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :label_type, :LLVMLabelType, [], :pointer

  # @method x86mmx_type()
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :x86mmx_type, :LLVMX86MMXType, [], :pointer

  # Operations on all values
  # 
  # @method type_of(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of TypeRef] 
  # @scope class
  attach_function :type_of, :LLVMTypeOf, [:pointer], :pointer

  # @method get_value_name(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [String] 
  # @scope class
  attach_function :get_value_name, :LLVMGetValueName, [:pointer], :string

  # @method set_value_name(val, name)
  # @param [FFI::Pointer of ValueRef] val 
  # @param [String] name 
  # @return [nil] 
  # @scope class
  attach_function :set_value_name, :LLVMSetValueName, [:pointer, :string], :void

  # @method dump_value(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [nil] 
  # @scope class
  attach_function :dump_value, :LLVMDumpValue, [:pointer], :void

  # @method replace_all_uses_with(old_val, new_val)
  # @param [FFI::Pointer of ValueRef] old_val 
  # @param [FFI::Pointer of ValueRef] new_val 
  # @return [nil] 
  # @scope class
  attach_function :replace_all_uses_with, :LLVMReplaceAllUsesWith, [:pointer, :pointer], :void

  # @method has_metadata(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [Integer] 
  # @scope class
  attach_function :has_metadata, :LLVMHasMetadata, [:pointer], :int

  # @method get_metadata(val, kind_id)
  # @param [FFI::Pointer of ValueRef] val 
  # @param [Integer] kind_id 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_metadata, :LLVMGetMetadata, [:pointer, :uint], :pointer

  # @method set_metadata(val, kind_id, node)
  # @param [FFI::Pointer of ValueRef] val 
  # @param [Integer] kind_id 
  # @param [FFI::Pointer of ValueRef] node 
  # @return [nil] 
  # @scope class
  attach_function :set_metadata, :LLVMSetMetadata, [:pointer, :uint, :pointer], :void

  # @method is_a_argument(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_argument, :LLVMIsAArgument, [:pointer], :pointer

  # @method is_a_basic_block(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_basic_block, :LLVMIsABasicBlock, [:pointer], :pointer

  # @method is_a_inline_asm(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_inline_asm, :LLVMIsAInlineAsm, [:pointer], :pointer

  # @method is_amd_node(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_amd_node, :LLVMIsAMDNode, [:pointer], :pointer

  # @method is_amd_string(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_amd_string, :LLVMIsAMDString, [:pointer], :pointer

  # @method is_a_user(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_user, :LLVMIsAUser, [:pointer], :pointer

  # @method is_a_constant(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_constant, :LLVMIsAConstant, [:pointer], :pointer

  # @method is_a_block_address(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_block_address, :LLVMIsABlockAddress, [:pointer], :pointer

  # @method is_a_constant_aggregate_zero(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_constant_aggregate_zero, :LLVMIsAConstantAggregateZero, [:pointer], :pointer

  # @method is_a_constant_array(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_constant_array, :LLVMIsAConstantArray, [:pointer], :pointer

  # @method is_a_constant_expr(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_constant_expr, :LLVMIsAConstantExpr, [:pointer], :pointer

  # @method is_a_constant_fp(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_constant_fp, :LLVMIsAConstantFP, [:pointer], :pointer

  # @method is_a_constant_int(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_constant_int, :LLVMIsAConstantInt, [:pointer], :pointer

  # @method is_a_constant_pointer_null(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_constant_pointer_null, :LLVMIsAConstantPointerNull, [:pointer], :pointer

  # @method is_a_constant_struct(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_constant_struct, :LLVMIsAConstantStruct, [:pointer], :pointer

  # @method is_a_constant_vector(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_constant_vector, :LLVMIsAConstantVector, [:pointer], :pointer

  # @method is_a_global_value(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_global_value, :LLVMIsAGlobalValue, [:pointer], :pointer

  # @method is_a_function(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_function, :LLVMIsAFunction, [:pointer], :pointer

  # @method is_a_global_alias(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_global_alias, :LLVMIsAGlobalAlias, [:pointer], :pointer

  # @method is_a_global_variable(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_global_variable, :LLVMIsAGlobalVariable, [:pointer], :pointer

  # @method is_a_undef_value(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_undef_value, :LLVMIsAUndefValue, [:pointer], :pointer

  # @method is_a_instruction(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_instruction, :LLVMIsAInstruction, [:pointer], :pointer

  # @method is_a_binary_operator(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_binary_operator, :LLVMIsABinaryOperator, [:pointer], :pointer

  # @method is_a_call_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_call_inst, :LLVMIsACallInst, [:pointer], :pointer

  # @method is_a_intrinsic_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_intrinsic_inst, :LLVMIsAIntrinsicInst, [:pointer], :pointer

  # @method is_a_dbg_info_intrinsic(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_dbg_info_intrinsic, :LLVMIsADbgInfoIntrinsic, [:pointer], :pointer

  # @method is_a_dbg_declare_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_dbg_declare_inst, :LLVMIsADbgDeclareInst, [:pointer], :pointer

  # @method is_aeh_exception_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_aeh_exception_inst, :LLVMIsAEHExceptionInst, [:pointer], :pointer

  # @method is_aeh_selector_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_aeh_selector_inst, :LLVMIsAEHSelectorInst, [:pointer], :pointer

  # @method is_a_mem_intrinsic(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_mem_intrinsic, :LLVMIsAMemIntrinsic, [:pointer], :pointer

  # @method is_a_mem_cpy_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_mem_cpy_inst, :LLVMIsAMemCpyInst, [:pointer], :pointer

  # @method is_a_mem_move_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_mem_move_inst, :LLVMIsAMemMoveInst, [:pointer], :pointer

  # @method is_a_mem_set_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_mem_set_inst, :LLVMIsAMemSetInst, [:pointer], :pointer

  # @method is_a_cmp_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_cmp_inst, :LLVMIsACmpInst, [:pointer], :pointer

  # @method is_af_cmp_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_af_cmp_inst, :LLVMIsAFCmpInst, [:pointer], :pointer

  # @method is_ai_cmp_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_ai_cmp_inst, :LLVMIsAICmpInst, [:pointer], :pointer

  # @method is_a_extract_element_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_extract_element_inst, :LLVMIsAExtractElementInst, [:pointer], :pointer

  # @method is_a_get_element_ptr_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_get_element_ptr_inst, :LLVMIsAGetElementPtrInst, [:pointer], :pointer

  # @method is_a_insert_element_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_insert_element_inst, :LLVMIsAInsertElementInst, [:pointer], :pointer

  # @method is_a_insert_value_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_insert_value_inst, :LLVMIsAInsertValueInst, [:pointer], :pointer

  # @method is_a_landing_pad_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_landing_pad_inst, :LLVMIsALandingPadInst, [:pointer], :pointer

  # @method is_aphi_node(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_aphi_node, :LLVMIsAPHINode, [:pointer], :pointer

  # @method is_a_select_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_select_inst, :LLVMIsASelectInst, [:pointer], :pointer

  # @method is_a_shuffle_vector_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_shuffle_vector_inst, :LLVMIsAShuffleVectorInst, [:pointer], :pointer

  # @method is_a_store_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_store_inst, :LLVMIsAStoreInst, [:pointer], :pointer

  # @method is_a_terminator_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_terminator_inst, :LLVMIsATerminatorInst, [:pointer], :pointer

  # @method is_a_branch_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_branch_inst, :LLVMIsABranchInst, [:pointer], :pointer

  # @method is_a_indirect_br_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_indirect_br_inst, :LLVMIsAIndirectBrInst, [:pointer], :pointer

  # @method is_a_invoke_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_invoke_inst, :LLVMIsAInvokeInst, [:pointer], :pointer

  # @method is_a_return_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_return_inst, :LLVMIsAReturnInst, [:pointer], :pointer

  # @method is_a_switch_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_switch_inst, :LLVMIsASwitchInst, [:pointer], :pointer

  # @method is_a_unreachable_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_unreachable_inst, :LLVMIsAUnreachableInst, [:pointer], :pointer

  # @method is_a_resume_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_resume_inst, :LLVMIsAResumeInst, [:pointer], :pointer

  # @method is_a_unary_instruction(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_unary_instruction, :LLVMIsAUnaryInstruction, [:pointer], :pointer

  # @method is_a_alloca_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_alloca_inst, :LLVMIsAAllocaInst, [:pointer], :pointer

  # @method is_a_cast_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_cast_inst, :LLVMIsACastInst, [:pointer], :pointer

  # @method is_a_bit_cast_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_bit_cast_inst, :LLVMIsABitCastInst, [:pointer], :pointer

  # @method is_afp_ext_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_afp_ext_inst, :LLVMIsAFPExtInst, [:pointer], :pointer

  # @method is_afp_to_si_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_afp_to_si_inst, :LLVMIsAFPToSIInst, [:pointer], :pointer

  # @method is_afp_to_ui_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_afp_to_ui_inst, :LLVMIsAFPToUIInst, [:pointer], :pointer

  # @method is_afp_trunc_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_afp_trunc_inst, :LLVMIsAFPTruncInst, [:pointer], :pointer

  # @method is_a_int_to_ptr_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_int_to_ptr_inst, :LLVMIsAIntToPtrInst, [:pointer], :pointer

  # @method is_a_ptr_to_int_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_ptr_to_int_inst, :LLVMIsAPtrToIntInst, [:pointer], :pointer

  # @method is_as_ext_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_as_ext_inst, :LLVMIsASExtInst, [:pointer], :pointer

  # @method is_asi_to_fp_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_asi_to_fp_inst, :LLVMIsASIToFPInst, [:pointer], :pointer

  # @method is_a_trunc_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_trunc_inst, :LLVMIsATruncInst, [:pointer], :pointer

  # @method is_aui_to_fp_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_aui_to_fp_inst, :LLVMIsAUIToFPInst, [:pointer], :pointer

  # @method is_az_ext_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_az_ext_inst, :LLVMIsAZExtInst, [:pointer], :pointer

  # @method is_a_extract_value_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_extract_value_inst, :LLVMIsAExtractValueInst, [:pointer], :pointer

  # @method is_a_load_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_a_load_inst, :LLVMIsALoadInst, [:pointer], :pointer

  # @method is_ava_arg_inst(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :is_ava_arg_inst, :LLVMIsAVAArgInst, [:pointer], :pointer

  # Operations on Uses
  # 
  # @method get_first_use(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of UseRef] 
  # @scope class
  attach_function :get_first_use, :LLVMGetFirstUse, [:pointer], :pointer

  # @method get_next_use(u)
  # @param [FFI::Pointer of UseRef] u 
  # @return [FFI::Pointer of UseRef] 
  # @scope class
  attach_function :get_next_use, :LLVMGetNextUse, [:pointer], :pointer

  # @method get_user(u)
  # @param [FFI::Pointer of UseRef] u 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_user, :LLVMGetUser, [:pointer], :pointer

  # @method get_used_value(u)
  # @param [FFI::Pointer of UseRef] u 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_used_value, :LLVMGetUsedValue, [:pointer], :pointer

  # Operations on Users
  # 
  # @method get_operand(val, index)
  # @param [FFI::Pointer of ValueRef] val 
  # @param [Integer] index 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_operand, :LLVMGetOperand, [:pointer, :uint], :pointer

  # @method set_operand(user, index, val)
  # @param [FFI::Pointer of ValueRef] user 
  # @param [Integer] index 
  # @param [FFI::Pointer of ValueRef] val 
  # @return [nil] 
  # @scope class
  attach_function :set_operand, :LLVMSetOperand, [:pointer, :uint, :pointer], :void

  # @method get_num_operands(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [Integer] 
  # @scope class
  attach_function :get_num_operands, :LLVMGetNumOperands, [:pointer], :int

  # Operations on constants of any type
  # 
  # @method const_null(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_null, :LLVMConstNull, [:pointer], :pointer

  # all zeroes
  # 
  # @method const_all_ones(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_all_ones, :LLVMConstAllOnes, [:pointer], :pointer

  # only for int/vector
  # 
  # @method get_undef(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_undef, :LLVMGetUndef, [:pointer], :pointer

  # @method is_constant(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [Integer] 
  # @scope class
  attach_function :is_constant, :LLVMIsConstant, [:pointer], :int

  # @method is_null(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [Integer] 
  # @scope class
  attach_function :is_null, :LLVMIsNull, [:pointer], :int

  # @method is_undef(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [Integer] 
  # @scope class
  attach_function :is_undef, :LLVMIsUndef, [:pointer], :int

  # @method const_pointer_null(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_pointer_null, :LLVMConstPointerNull, [:pointer], :pointer

  # Operations on metadata
  # 
  # @method md_string_in_context(c, str, s_len)
  # @param [FFI::Pointer of ContextRef] c 
  # @param [String] str 
  # @param [Integer] s_len 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :md_string_in_context, :LLVMMDStringInContext, [:pointer, :string, :uint], :pointer

  # @method md_string(str, s_len)
  # @param [String] str 
  # @param [Integer] s_len 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :md_string, :LLVMMDString, [:string, :uint], :pointer

  # @method md_node_in_context(c, vals, count)
  # @param [FFI::Pointer of ContextRef] c 
  # @param [FFI::Pointer to ] vals 
  # @param [Integer] count 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :md_node_in_context, :LLVMMDNodeInContext, [:pointer, :pointer, :uint], :pointer

  # @method md_node(vals, count)
  # @param [FFI::Pointer to ] vals 
  # @param [Integer] count 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :md_node, :LLVMMDNode, [:pointer, :uint], :pointer

  # @method get_md_string(v, len)
  # @param [FFI::Pointer of ValueRef] v 
  # @param [FFI::Pointer to ] len 
  # @return [String] 
  # @scope class
  attach_function :get_md_string, :LLVMGetMDString, [:pointer, :pointer], :string

  # @method get_named_metadata_num_operands(m, name)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [String] name 
  # @return [Integer] 
  # @scope class
  attach_function :get_named_metadata_num_operands, :LLVMGetNamedMetadataNumOperands, [:pointer, :string], :uint

  # @method get_named_metadata_operands(m, name, dest)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [String] name 
  # @param [FFI::Pointer to ] dest 
  # @return [nil] 
  # @scope class
  attach_function :get_named_metadata_operands, :LLVMGetNamedMetadataOperands, [:pointer, :string, :pointer], :void

  # Operations on scalar constants
  # 
  # @method const_int(int_ty, n, sign_extend)
  # @param [FFI::Pointer of TypeRef] int_ty 
  # @param [Integer] n 
  # @param [Integer] sign_extend 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_int, :LLVMConstInt, [:pointer, :ulong_long, :int], :pointer

  # @method const_int_of_arbitrary_precision(int_ty, num_words, words)
  # @param [FFI::Pointer of TypeRef] int_ty 
  # @param [Integer] num_words 
  # @param [FFI::Pointer to ] words 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_int_of_arbitrary_precision, :LLVMConstIntOfArbitraryPrecision, [:pointer, :uint, :pointer], :pointer

  # @method const_int_of_string(int_ty, text, radix)
  # @param [FFI::Pointer of TypeRef] int_ty 
  # @param [String] text 
  # @param [Integer] radix 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_int_of_string, :LLVMConstIntOfString, [:pointer, :string, :uchar], :pointer

  # @method const_int_of_string_and_size(int_ty, text, s_len, radix)
  # @param [FFI::Pointer of TypeRef] int_ty 
  # @param [String] text 
  # @param [Integer] s_len 
  # @param [Integer] radix 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_int_of_string_and_size, :LLVMConstIntOfStringAndSize, [:pointer, :string, :uint, :uchar], :pointer

  # @method const_real(real_ty, n)
  # @param [FFI::Pointer of TypeRef] real_ty 
  # @param [Float] n 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_real, :LLVMConstReal, [:pointer, :double], :pointer

  # @method const_real_of_string(real_ty, text)
  # @param [FFI::Pointer of TypeRef] real_ty 
  # @param [String] text 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_real_of_string, :LLVMConstRealOfString, [:pointer, :string], :pointer

  # @method const_real_of_string_and_size(real_ty, text, s_len)
  # @param [FFI::Pointer of TypeRef] real_ty 
  # @param [String] text 
  # @param [Integer] s_len 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_real_of_string_and_size, :LLVMConstRealOfStringAndSize, [:pointer, :string, :uint], :pointer

  # @method const_int_get_z_ext_value(constant_val)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @return [Integer] 
  # @scope class
  attach_function :const_int_get_z_ext_value, :LLVMConstIntGetZExtValue, [:pointer], :ulong_long

  # @method const_int_get_s_ext_value(constant_val)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @return [Integer] 
  # @scope class
  attach_function :const_int_get_s_ext_value, :LLVMConstIntGetSExtValue, [:pointer], :long_long

  # Operations on composite constants
  # 
  # @method const_string_in_context(c, str, length, dont_null_terminate)
  # @param [FFI::Pointer of ContextRef] c 
  # @param [String] str 
  # @param [Integer] length 
  # @param [Integer] dont_null_terminate 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_string_in_context, :LLVMConstStringInContext, [:pointer, :string, :uint, :int], :pointer

  # @method const_struct_in_context(c, constant_vals, count, packed)
  # @param [FFI::Pointer of ContextRef] c 
  # @param [FFI::Pointer to ] constant_vals 
  # @param [Integer] count 
  # @param [Integer] packed 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_struct_in_context, :LLVMConstStructInContext, [:pointer, :pointer, :uint, :int], :pointer

  # @method const_string(str, length, dont_null_terminate)
  # @param [String] str 
  # @param [Integer] length 
  # @param [Integer] dont_null_terminate 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_string, :LLVMConstString, [:string, :uint, :int], :pointer

  # @method const_array(element_ty, constant_vals, length)
  # @param [FFI::Pointer of TypeRef] element_ty 
  # @param [FFI::Pointer to ] constant_vals 
  # @param [Integer] length 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_array, :LLVMConstArray, [:pointer, :pointer, :uint], :pointer

  # @method const_struct(constant_vals, count, packed)
  # @param [FFI::Pointer to ] constant_vals 
  # @param [Integer] count 
  # @param [Integer] packed 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_struct, :LLVMConstStruct, [:pointer, :uint, :int], :pointer

  # @method const_named_struct(struct_ty, constant_vals, count)
  # @param [FFI::Pointer of TypeRef] struct_ty 
  # @param [FFI::Pointer to ] constant_vals 
  # @param [Integer] count 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_named_struct, :LLVMConstNamedStruct, [:pointer, :pointer, :uint], :pointer

  # @method const_vector(scalar_constant_vals, size)
  # @param [FFI::Pointer to ] scalar_constant_vals 
  # @param [Integer] size 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_vector, :LLVMConstVector, [:pointer, :uint], :pointer

  # Constant expressions
  # 
  # @method get_const_opcode(constant_val)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @return [Symbol from opcode_enum] 
  # @scope class
  attach_function :get_const_opcode, :LLVMGetConstOpcode, [:pointer], :opcode

  # @method align_of(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :align_of, :LLVMAlignOf, [:pointer], :pointer

  # @method size_of(ty)
  # @param [FFI::Pointer of TypeRef] ty 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :size_of, :LLVMSizeOf, [:pointer], :pointer

  # @method const_neg(constant_val)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_neg, :LLVMConstNeg, [:pointer], :pointer

  # @method const_nsw_neg(constant_val)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_nsw_neg, :LLVMConstNSWNeg, [:pointer], :pointer

  # @method const_nuw_neg(constant_val)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_nuw_neg, :LLVMConstNUWNeg, [:pointer], :pointer

  # @method const_f_neg(constant_val)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_f_neg, :LLVMConstFNeg, [:pointer], :pointer

  # @method const_not(constant_val)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_not, :LLVMConstNot, [:pointer], :pointer

  # @method const_add(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_add, :LLVMConstAdd, [:pointer, :pointer], :pointer

  # @method const_nsw_add(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_nsw_add, :LLVMConstNSWAdd, [:pointer, :pointer], :pointer

  # @method const_nuw_add(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_nuw_add, :LLVMConstNUWAdd, [:pointer, :pointer], :pointer

  # @method const_f_add(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_f_add, :LLVMConstFAdd, [:pointer, :pointer], :pointer

  # @method const_sub(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_sub, :LLVMConstSub, [:pointer, :pointer], :pointer

  # @method const_nsw_sub(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_nsw_sub, :LLVMConstNSWSub, [:pointer, :pointer], :pointer

  # @method const_nuw_sub(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_nuw_sub, :LLVMConstNUWSub, [:pointer, :pointer], :pointer

  # @method const_f_sub(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_f_sub, :LLVMConstFSub, [:pointer, :pointer], :pointer

  # @method const_mul(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_mul, :LLVMConstMul, [:pointer, :pointer], :pointer

  # @method const_nsw_mul(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_nsw_mul, :LLVMConstNSWMul, [:pointer, :pointer], :pointer

  # @method const_nuw_mul(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_nuw_mul, :LLVMConstNUWMul, [:pointer, :pointer], :pointer

  # @method const_f_mul(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_f_mul, :LLVMConstFMul, [:pointer, :pointer], :pointer

  # @method const_u_div(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_u_div, :LLVMConstUDiv, [:pointer, :pointer], :pointer

  # @method const_s_div(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_s_div, :LLVMConstSDiv, [:pointer, :pointer], :pointer

  # @method const_exact_s_div(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_exact_s_div, :LLVMConstExactSDiv, [:pointer, :pointer], :pointer

  # @method const_f_div(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_f_div, :LLVMConstFDiv, [:pointer, :pointer], :pointer

  # @method const_u_rem(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_u_rem, :LLVMConstURem, [:pointer, :pointer], :pointer

  # @method const_s_rem(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_s_rem, :LLVMConstSRem, [:pointer, :pointer], :pointer

  # @method const_f_rem(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_f_rem, :LLVMConstFRem, [:pointer, :pointer], :pointer

  # @method const_and(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_and, :LLVMConstAnd, [:pointer, :pointer], :pointer

  # @method const_or(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_or, :LLVMConstOr, [:pointer, :pointer], :pointer

  # @method const_xor(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_xor, :LLVMConstXor, [:pointer, :pointer], :pointer

  # @method const_i_cmp(predicate, lhs_constant, rhs_constant)
  # @param [Symbol from int_predicate_enum] predicate 
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_i_cmp, :LLVMConstICmp, [:int_predicate, :pointer, :pointer], :pointer

  # @method const_f_cmp(predicate, lhs_constant, rhs_constant)
  # @param [Symbol from real_predicate_enum] predicate 
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_f_cmp, :LLVMConstFCmp, [:real_predicate, :pointer, :pointer], :pointer

  # @method const_shl(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_shl, :LLVMConstShl, [:pointer, :pointer], :pointer

  # @method const_l_shr(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_l_shr, :LLVMConstLShr, [:pointer, :pointer], :pointer

  # @method const_a_shr(lhs_constant, rhs_constant)
  # @param [FFI::Pointer of ValueRef] lhs_constant 
  # @param [FFI::Pointer of ValueRef] rhs_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_a_shr, :LLVMConstAShr, [:pointer, :pointer], :pointer

  # @method const_gep(constant_val, constant_indices, num_indices)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer to ] constant_indices 
  # @param [Integer] num_indices 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_gep, :LLVMConstGEP, [:pointer, :pointer, :uint], :pointer

  # @method const_in_bounds_gep(constant_val, constant_indices, num_indices)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer to ] constant_indices 
  # @param [Integer] num_indices 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_in_bounds_gep, :LLVMConstInBoundsGEP, [:pointer, :pointer, :uint], :pointer

  # @method const_trunc(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_trunc, :LLVMConstTrunc, [:pointer, :pointer], :pointer

  # @method const_s_ext(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_s_ext, :LLVMConstSExt, [:pointer, :pointer], :pointer

  # @method const_z_ext(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_z_ext, :LLVMConstZExt, [:pointer, :pointer], :pointer

  # @method const_fp_trunc(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_fp_trunc, :LLVMConstFPTrunc, [:pointer, :pointer], :pointer

  # @method const_fp_ext(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_fp_ext, :LLVMConstFPExt, [:pointer, :pointer], :pointer

  # @method const_ui_to_fp(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_ui_to_fp, :LLVMConstUIToFP, [:pointer, :pointer], :pointer

  # @method const_si_to_fp(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_si_to_fp, :LLVMConstSIToFP, [:pointer, :pointer], :pointer

  # @method const_fp_to_ui(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_fp_to_ui, :LLVMConstFPToUI, [:pointer, :pointer], :pointer

  # @method const_fp_to_si(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_fp_to_si, :LLVMConstFPToSI, [:pointer, :pointer], :pointer

  # @method const_ptr_to_int(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_ptr_to_int, :LLVMConstPtrToInt, [:pointer, :pointer], :pointer

  # @method const_int_to_ptr(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_int_to_ptr, :LLVMConstIntToPtr, [:pointer, :pointer], :pointer

  # @method const_bit_cast(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_bit_cast, :LLVMConstBitCast, [:pointer, :pointer], :pointer

  # @method const_z_ext_or_bit_cast(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_z_ext_or_bit_cast, :LLVMConstZExtOrBitCast, [:pointer, :pointer], :pointer

  # @method const_s_ext_or_bit_cast(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_s_ext_or_bit_cast, :LLVMConstSExtOrBitCast, [:pointer, :pointer], :pointer

  # @method const_trunc_or_bit_cast(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_trunc_or_bit_cast, :LLVMConstTruncOrBitCast, [:pointer, :pointer], :pointer

  # @method const_pointer_cast(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_pointer_cast, :LLVMConstPointerCast, [:pointer, :pointer], :pointer

  # @method const_int_cast(constant_val, to_type, is_signed)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @param [Integer] is_signed 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_int_cast, :LLVMConstIntCast, [:pointer, :pointer, :int], :pointer

  # @method const_fp_cast(constant_val, to_type)
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @param [FFI::Pointer of TypeRef] to_type 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_fp_cast, :LLVMConstFPCast, [:pointer, :pointer], :pointer

  # @method const_select(constant_condition, constant_if_true, constant_if_false)
  # @param [FFI::Pointer of ValueRef] constant_condition 
  # @param [FFI::Pointer of ValueRef] constant_if_true 
  # @param [FFI::Pointer of ValueRef] constant_if_false 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_select, :LLVMConstSelect, [:pointer, :pointer, :pointer], :pointer

  # @method const_extract_element(vector_constant, index_constant)
  # @param [FFI::Pointer of ValueRef] vector_constant 
  # @param [FFI::Pointer of ValueRef] index_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_extract_element, :LLVMConstExtractElement, [:pointer, :pointer], :pointer

  # @method const_insert_element(vector_constant, element_value_constant, index_constant)
  # @param [FFI::Pointer of ValueRef] vector_constant 
  # @param [FFI::Pointer of ValueRef] element_value_constant 
  # @param [FFI::Pointer of ValueRef] index_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_insert_element, :LLVMConstInsertElement, [:pointer, :pointer, :pointer], :pointer

  # @method const_shuffle_vector(vector_a_constant, vector_b_constant, mask_constant)
  # @param [FFI::Pointer of ValueRef] vector_a_constant 
  # @param [FFI::Pointer of ValueRef] vector_b_constant 
  # @param [FFI::Pointer of ValueRef] mask_constant 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_shuffle_vector, :LLVMConstShuffleVector, [:pointer, :pointer, :pointer], :pointer

  # @method const_extract_value(agg_constant, idx_list, num_idx)
  # @param [FFI::Pointer of ValueRef] agg_constant 
  # @param [FFI::Pointer to ] idx_list 
  # @param [Integer] num_idx 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_extract_value, :LLVMConstExtractValue, [:pointer, :pointer, :uint], :pointer

  # @method const_insert_value(agg_constant, element_value_constant, idx_list, num_idx)
  # @param [FFI::Pointer of ValueRef] agg_constant 
  # @param [FFI::Pointer of ValueRef] element_value_constant 
  # @param [FFI::Pointer to ] idx_list 
  # @param [Integer] num_idx 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_insert_value, :LLVMConstInsertValue, [:pointer, :pointer, :pointer, :uint], :pointer

  # @method const_inline_asm(ty, asm_string, constraints, has_side_effects, is_align_stack)
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [String] asm_string 
  # @param [String] constraints 
  # @param [Integer] has_side_effects 
  # @param [Integer] is_align_stack 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :const_inline_asm, :LLVMConstInlineAsm, [:pointer, :string, :string, :int, :int], :pointer

  # @method block_address(f, bb)
  # @param [FFI::Pointer of ValueRef] f 
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :block_address, :LLVMBlockAddress, [:pointer, :pointer], :pointer

  # Operations on global variables, functions, and aliases (globals)
  # 
  # @method get_global_parent(global)
  # @param [FFI::Pointer of ValueRef] global 
  # @return [FFI::Pointer of ModuleRef] 
  # @scope class
  attach_function :get_global_parent, :LLVMGetGlobalParent, [:pointer], :pointer

  # @method is_declaration(global)
  # @param [FFI::Pointer of ValueRef] global 
  # @return [Integer] 
  # @scope class
  attach_function :is_declaration, :LLVMIsDeclaration, [:pointer], :int

  # @method get_linkage(global)
  # @param [FFI::Pointer of ValueRef] global 
  # @return [Symbol from linkage_enum] 
  # @scope class
  attach_function :get_linkage, :LLVMGetLinkage, [:pointer], :linkage

  # @method set_linkage(global, linkage)
  # @param [FFI::Pointer of ValueRef] global 
  # @param [Symbol from linkage_enum] linkage 
  # @return [nil] 
  # @scope class
  attach_function :set_linkage, :LLVMSetLinkage, [:pointer, :linkage], :void

  # @method get_section(global)
  # @param [FFI::Pointer of ValueRef] global 
  # @return [String] 
  # @scope class
  attach_function :get_section, :LLVMGetSection, [:pointer], :string

  # @method set_section(global, section)
  # @param [FFI::Pointer of ValueRef] global 
  # @param [String] section 
  # @return [nil] 
  # @scope class
  attach_function :set_section, :LLVMSetSection, [:pointer, :string], :void

  # @method get_visibility(global)
  # @param [FFI::Pointer of ValueRef] global 
  # @return [Symbol from visibility_enum] 
  # @scope class
  attach_function :get_visibility, :LLVMGetVisibility, [:pointer], :visibility

  # @method set_visibility(global, viz)
  # @param [FFI::Pointer of ValueRef] global 
  # @param [Symbol from visibility_enum] viz 
  # @return [nil] 
  # @scope class
  attach_function :set_visibility, :LLVMSetVisibility, [:pointer, :visibility], :void

  # @method get_alignment(global)
  # @param [FFI::Pointer of ValueRef] global 
  # @return [Integer] 
  # @scope class
  attach_function :get_alignment, :LLVMGetAlignment, [:pointer], :uint

  # @method set_alignment(global, bytes)
  # @param [FFI::Pointer of ValueRef] global 
  # @param [Integer] bytes 
  # @return [nil] 
  # @scope class
  attach_function :set_alignment, :LLVMSetAlignment, [:pointer, :uint], :void

  # Operations on global variables
  # 
  # @method add_global(m, ty, name)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :add_global, :LLVMAddGlobal, [:pointer, :pointer, :string], :pointer

  # @method add_global_in_address_space(m, ty, name, address_space)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [String] name 
  # @param [Integer] address_space 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :add_global_in_address_space, :LLVMAddGlobalInAddressSpace, [:pointer, :pointer, :string, :uint], :pointer

  # @method get_named_global(m, name)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_named_global, :LLVMGetNamedGlobal, [:pointer, :string], :pointer

  # @method get_first_global(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_first_global, :LLVMGetFirstGlobal, [:pointer], :pointer

  # @method get_last_global(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_last_global, :LLVMGetLastGlobal, [:pointer], :pointer

  # @method get_next_global(global_var)
  # @param [FFI::Pointer of ValueRef] global_var 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_next_global, :LLVMGetNextGlobal, [:pointer], :pointer

  # @method get_previous_global(global_var)
  # @param [FFI::Pointer of ValueRef] global_var 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_previous_global, :LLVMGetPreviousGlobal, [:pointer], :pointer

  # @method delete_global(global_var)
  # @param [FFI::Pointer of ValueRef] global_var 
  # @return [nil] 
  # @scope class
  attach_function :delete_global, :LLVMDeleteGlobal, [:pointer], :void

  # @method get_initializer(global_var)
  # @param [FFI::Pointer of ValueRef] global_var 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_initializer, :LLVMGetInitializer, [:pointer], :pointer

  # @method set_initializer(global_var, constant_val)
  # @param [FFI::Pointer of ValueRef] global_var 
  # @param [FFI::Pointer of ValueRef] constant_val 
  # @return [nil] 
  # @scope class
  attach_function :set_initializer, :LLVMSetInitializer, [:pointer, :pointer], :void

  # @method is_thread_local(global_var)
  # @param [FFI::Pointer of ValueRef] global_var 
  # @return [Integer] 
  # @scope class
  attach_function :is_thread_local, :LLVMIsThreadLocal, [:pointer], :int

  # @method set_thread_local(global_var, is_thread_local)
  # @param [FFI::Pointer of ValueRef] global_var 
  # @param [Integer] is_thread_local 
  # @return [nil] 
  # @scope class
  attach_function :set_thread_local, :LLVMSetThreadLocal, [:pointer, :int], :void

  # @method is_global_constant(global_var)
  # @param [FFI::Pointer of ValueRef] global_var 
  # @return [Integer] 
  # @scope class
  attach_function :is_global_constant, :LLVMIsGlobalConstant, [:pointer], :int

  # @method set_global_constant(global_var, is_constant)
  # @param [FFI::Pointer of ValueRef] global_var 
  # @param [Integer] is_constant 
  # @return [nil] 
  # @scope class
  attach_function :set_global_constant, :LLVMSetGlobalConstant, [:pointer, :int], :void

  # Operations on aliases
  # 
  # @method add_alias(m, ty, aliasee, name)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [FFI::Pointer of ValueRef] aliasee 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :add_alias, :LLVMAddAlias, [:pointer, :pointer, :pointer, :string], :pointer

  # Operations on functions
  # 
  # @method add_function(m, name, function_ty)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [String] name 
  # @param [FFI::Pointer of TypeRef] function_ty 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :add_function, :LLVMAddFunction, [:pointer, :string, :pointer], :pointer

  # @method get_named_function(m, name)
  # @param [FFI::Pointer of ModuleRef] m 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_named_function, :LLVMGetNamedFunction, [:pointer, :string], :pointer

  # @method get_first_function(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_first_function, :LLVMGetFirstFunction, [:pointer], :pointer

  # @method get_last_function(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_last_function, :LLVMGetLastFunction, [:pointer], :pointer

  # @method get_next_function(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_next_function, :LLVMGetNextFunction, [:pointer], :pointer

  # @method get_previous_function(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_previous_function, :LLVMGetPreviousFunction, [:pointer], :pointer

  # @method delete_function(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [nil] 
  # @scope class
  attach_function :delete_function, :LLVMDeleteFunction, [:pointer], :void

  # @method get_intrinsic_id(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [Integer] 
  # @scope class
  attach_function :get_intrinsic_id, :LLVMGetIntrinsicID, [:pointer], :uint

  # @method get_function_call_conv(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [Integer] 
  # @scope class
  attach_function :get_function_call_conv, :LLVMGetFunctionCallConv, [:pointer], :uint

  # @method set_function_call_conv(fn, cc)
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [Integer] cc 
  # @return [nil] 
  # @scope class
  attach_function :set_function_call_conv, :LLVMSetFunctionCallConv, [:pointer, :uint], :void

  # @method get_gc(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [String] 
  # @scope class
  attach_function :get_gc, :LLVMGetGC, [:pointer], :string

  # @method set_gc(fn, name)
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [String] name 
  # @return [nil] 
  # @scope class
  attach_function :set_gc, :LLVMSetGC, [:pointer, :string], :void

  # @method add_function_attr(fn, pa)
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [Symbol from attribute_enum] pa 
  # @return [nil] 
  # @scope class
  attach_function :add_function_attr, :LLVMAddFunctionAttr, [:pointer, :attribute], :void

  # @method get_function_attr(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [Symbol from attribute_enum] 
  # @scope class
  attach_function :get_function_attr, :LLVMGetFunctionAttr, [:pointer], :attribute

  # @method remove_function_attr(fn, pa)
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [Symbol from attribute_enum] pa 
  # @return [nil] 
  # @scope class
  attach_function :remove_function_attr, :LLVMRemoveFunctionAttr, [:pointer, :attribute], :void

  # Operations on parameters
  # 
  # @method count_params(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [Integer] 
  # @scope class
  attach_function :count_params, :LLVMCountParams, [:pointer], :uint

  # @method get_params(fn, params)
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [FFI::Pointer to ] params 
  # @return [nil] 
  # @scope class
  attach_function :get_params, :LLVMGetParams, [:pointer, :pointer], :void

  # @method get_param(fn, index)
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [Integer] index 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_param, :LLVMGetParam, [:pointer, :uint], :pointer

  # @method get_param_parent(inst)
  # @param [FFI::Pointer of ValueRef] inst 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_param_parent, :LLVMGetParamParent, [:pointer], :pointer

  # @method get_first_param(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_first_param, :LLVMGetFirstParam, [:pointer], :pointer

  # @method get_last_param(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_last_param, :LLVMGetLastParam, [:pointer], :pointer

  # @method get_next_param(arg)
  # @param [FFI::Pointer of ValueRef] arg 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_next_param, :LLVMGetNextParam, [:pointer], :pointer

  # @method get_previous_param(arg)
  # @param [FFI::Pointer of ValueRef] arg 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_previous_param, :LLVMGetPreviousParam, [:pointer], :pointer

  # @method add_attribute(arg, pa)
  # @param [FFI::Pointer of ValueRef] arg 
  # @param [Symbol from attribute_enum] pa 
  # @return [nil] 
  # @scope class
  attach_function :add_attribute, :LLVMAddAttribute, [:pointer, :attribute], :void

  # @method remove_attribute(arg, pa)
  # @param [FFI::Pointer of ValueRef] arg 
  # @param [Symbol from attribute_enum] pa 
  # @return [nil] 
  # @scope class
  attach_function :remove_attribute, :LLVMRemoveAttribute, [:pointer, :attribute], :void

  # @method get_attribute(arg)
  # @param [FFI::Pointer of ValueRef] arg 
  # @return [Symbol from attribute_enum] 
  # @scope class
  attach_function :get_attribute, :LLVMGetAttribute, [:pointer], :attribute

  # @method set_param_alignment(arg, align)
  # @param [FFI::Pointer of ValueRef] arg 
  # @param [Integer] align 
  # @return [nil] 
  # @scope class
  attach_function :set_param_alignment, :LLVMSetParamAlignment, [:pointer, :uint], :void

  # Operations on basic blocks
  # 
  # @method basic_block_as_value(bb)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :basic_block_as_value, :LLVMBasicBlockAsValue, [:pointer], :pointer

  # @method value_is_basic_block(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [Integer] 
  # @scope class
  attach_function :value_is_basic_block, :LLVMValueIsBasicBlock, [:pointer], :int

  # @method value_as_basic_block(val)
  # @param [FFI::Pointer of ValueRef] val 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :value_as_basic_block, :LLVMValueAsBasicBlock, [:pointer], :pointer

  # @method get_basic_block_parent(bb)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_basic_block_parent, :LLVMGetBasicBlockParent, [:pointer], :pointer

  # @method get_basic_block_terminator(bb)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_basic_block_terminator, :LLVMGetBasicBlockTerminator, [:pointer], :pointer

  # @method count_basic_blocks(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [Integer] 
  # @scope class
  attach_function :count_basic_blocks, :LLVMCountBasicBlocks, [:pointer], :uint

  # @method get_basic_blocks(fn, basic_blocks)
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [FFI::Pointer to ] basic_blocks 
  # @return [nil] 
  # @scope class
  attach_function :get_basic_blocks, :LLVMGetBasicBlocks, [:pointer, :pointer], :void

  # @method get_first_basic_block(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :get_first_basic_block, :LLVMGetFirstBasicBlock, [:pointer], :pointer

  # @method get_last_basic_block(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :get_last_basic_block, :LLVMGetLastBasicBlock, [:pointer], :pointer

  # @method get_next_basic_block(bb)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :get_next_basic_block, :LLVMGetNextBasicBlock, [:pointer], :pointer

  # @method get_previous_basic_block(bb)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :get_previous_basic_block, :LLVMGetPreviousBasicBlock, [:pointer], :pointer

  # @method get_entry_basic_block(fn)
  # @param [FFI::Pointer of ValueRef] fn 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :get_entry_basic_block, :LLVMGetEntryBasicBlock, [:pointer], :pointer

  # @method append_basic_block_in_context(c, fn, name)
  # @param [FFI::Pointer of ContextRef] c 
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [String] name 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :append_basic_block_in_context, :LLVMAppendBasicBlockInContext, [:pointer, :pointer, :string], :pointer

  # @method insert_basic_block_in_context(c, bb, name)
  # @param [FFI::Pointer of ContextRef] c 
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @param [String] name 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :insert_basic_block_in_context, :LLVMInsertBasicBlockInContext, [:pointer, :pointer, :string], :pointer

  # @method append_basic_block(fn, name)
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [String] name 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :append_basic_block, :LLVMAppendBasicBlock, [:pointer, :string], :pointer

  # @method insert_basic_block(insert_before_bb, name)
  # @param [FFI::Pointer of BasicBlockRef] insert_before_bb 
  # @param [String] name 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :insert_basic_block, :LLVMInsertBasicBlock, [:pointer, :string], :pointer

  # @method delete_basic_block(bb)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @return [nil] 
  # @scope class
  attach_function :delete_basic_block, :LLVMDeleteBasicBlock, [:pointer], :void

  # @method remove_basic_block_from_parent(bb)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @return [nil] 
  # @scope class
  attach_function :remove_basic_block_from_parent, :LLVMRemoveBasicBlockFromParent, [:pointer], :void

  # @method move_basic_block_before(bb, move_pos)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @param [FFI::Pointer of BasicBlockRef] move_pos 
  # @return [nil] 
  # @scope class
  attach_function :move_basic_block_before, :LLVMMoveBasicBlockBefore, [:pointer, :pointer], :void

  # @method move_basic_block_after(bb, move_pos)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @param [FFI::Pointer of BasicBlockRef] move_pos 
  # @return [nil] 
  # @scope class
  attach_function :move_basic_block_after, :LLVMMoveBasicBlockAfter, [:pointer, :pointer], :void

  # @method get_first_instruction(bb)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_first_instruction, :LLVMGetFirstInstruction, [:pointer], :pointer

  # @method get_last_instruction(bb)
  # @param [FFI::Pointer of BasicBlockRef] bb 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_last_instruction, :LLVMGetLastInstruction, [:pointer], :pointer

  # Operations on instructions
  # 
  # @method get_instruction_parent(inst)
  # @param [FFI::Pointer of ValueRef] inst 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :get_instruction_parent, :LLVMGetInstructionParent, [:pointer], :pointer

  # @method get_next_instruction(inst)
  # @param [FFI::Pointer of ValueRef] inst 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_next_instruction, :LLVMGetNextInstruction, [:pointer], :pointer

  # @method get_previous_instruction(inst)
  # @param [FFI::Pointer of ValueRef] inst 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_previous_instruction, :LLVMGetPreviousInstruction, [:pointer], :pointer

  # @method instruction_erase_from_parent(inst)
  # @param [FFI::Pointer of ValueRef] inst 
  # @return [nil] 
  # @scope class
  attach_function :instruction_erase_from_parent, :LLVMInstructionEraseFromParent, [:pointer], :void

  # @method get_instruction_opcode(inst)
  # @param [FFI::Pointer of ValueRef] inst 
  # @return [Symbol from opcode_enum] 
  # @scope class
  attach_function :get_instruction_opcode, :LLVMGetInstructionOpcode, [:pointer], :opcode

  # @method get_i_cmp_predicate(inst)
  # @param [FFI::Pointer of ValueRef] inst 
  # @return [Symbol from int_predicate_enum] 
  # @scope class
  attach_function :get_i_cmp_predicate, :LLVMGetICmpPredicate, [:pointer], :int_predicate

  # Operations on call sites
  # 
  # @method set_instruction_call_conv(instr, cc)
  # @param [FFI::Pointer of ValueRef] instr 
  # @param [Integer] cc 
  # @return [nil] 
  # @scope class
  attach_function :set_instruction_call_conv, :LLVMSetInstructionCallConv, [:pointer, :uint], :void

  # @method get_instruction_call_conv(instr)
  # @param [FFI::Pointer of ValueRef] instr 
  # @return [Integer] 
  # @scope class
  attach_function :get_instruction_call_conv, :LLVMGetInstructionCallConv, [:pointer], :uint

  # @method add_instr_attribute(instr, index, attribute_enum)
  # @param [FFI::Pointer of ValueRef] instr 
  # @param [Integer] index 
  # @param [Symbol from attribute_enum] attribute_enum 
  # @return [nil] 
  # @scope class
  attach_function :add_instr_attribute, :LLVMAddInstrAttribute, [:pointer, :uint, :attribute], :void

  # @method remove_instr_attribute(instr, index, attribute_enum)
  # @param [FFI::Pointer of ValueRef] instr 
  # @param [Integer] index 
  # @param [Symbol from attribute_enum] attribute_enum 
  # @return [nil] 
  # @scope class
  attach_function :remove_instr_attribute, :LLVMRemoveInstrAttribute, [:pointer, :uint, :attribute], :void

  # @method set_instr_param_alignment(instr, index, align)
  # @param [FFI::Pointer of ValueRef] instr 
  # @param [Integer] index 
  # @param [Integer] align 
  # @return [nil] 
  # @scope class
  attach_function :set_instr_param_alignment, :LLVMSetInstrParamAlignment, [:pointer, :uint, :uint], :void

  # Operations on call instructions (only)
  # 
  # @method is_tail_call(call_inst)
  # @param [FFI::Pointer of ValueRef] call_inst 
  # @return [Integer] 
  # @scope class
  attach_function :is_tail_call, :LLVMIsTailCall, [:pointer], :int

  # @method set_tail_call(call_inst, is_tail_call)
  # @param [FFI::Pointer of ValueRef] call_inst 
  # @param [Integer] is_tail_call 
  # @return [nil] 
  # @scope class
  attach_function :set_tail_call, :LLVMSetTailCall, [:pointer, :int], :void

  # Operations on switch instructions (only)
  # 
  # @method get_switch_default_dest(switch_instr)
  # @param [FFI::Pointer of ValueRef] switch_instr 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :get_switch_default_dest, :LLVMGetSwitchDefaultDest, [:pointer], :pointer

  # Operations on phi nodes
  # 
  # @method add_incoming(phi_node, incoming_values, incoming_blocks, count)
  # @param [FFI::Pointer of ValueRef] phi_node 
  # @param [FFI::Pointer to ] incoming_values 
  # @param [FFI::Pointer to ] incoming_blocks 
  # @param [Integer] count 
  # @return [nil] 
  # @scope class
  attach_function :add_incoming, :LLVMAddIncoming, [:pointer, :pointer, :pointer, :uint], :void

  # @method count_incoming(phi_node)
  # @param [FFI::Pointer of ValueRef] phi_node 
  # @return [Integer] 
  # @scope class
  attach_function :count_incoming, :LLVMCountIncoming, [:pointer], :uint

  # @method get_incoming_value(phi_node, index)
  # @param [FFI::Pointer of ValueRef] phi_node 
  # @param [Integer] index 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_incoming_value, :LLVMGetIncomingValue, [:pointer, :uint], :pointer

  # @method get_incoming_block(phi_node, index)
  # @param [FFI::Pointer of ValueRef] phi_node 
  # @param [Integer] index 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :get_incoming_block, :LLVMGetIncomingBlock, [:pointer, :uint], :pointer

  # An instruction builder represents a point within a basic block, and is the
  # exclusive means of building instructions using the C interface.
  # 
  # @method create_builder_in_context(c)
  # @param [FFI::Pointer of ContextRef] c 
  # @return [FFI::Pointer of BuilderRef] 
  # @scope class
  attach_function :create_builder_in_context, :LLVMCreateBuilderInContext, [:pointer], :pointer

  # @method create_builder()
  # @return [FFI::Pointer of BuilderRef] 
  # @scope class
  attach_function :create_builder, :LLVMCreateBuilder, [], :pointer

  # @method position_builder(builder, block, instr)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @param [FFI::Pointer of BasicBlockRef] block 
  # @param [FFI::Pointer of ValueRef] instr 
  # @return [nil] 
  # @scope class
  attach_function :position_builder, :LLVMPositionBuilder, [:pointer, :pointer, :pointer], :void

  # @method position_builder_before(builder, instr)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @param [FFI::Pointer of ValueRef] instr 
  # @return [nil] 
  # @scope class
  attach_function :position_builder_before, :LLVMPositionBuilderBefore, [:pointer, :pointer], :void

  # @method position_builder_at_end(builder, block)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @param [FFI::Pointer of BasicBlockRef] block 
  # @return [nil] 
  # @scope class
  attach_function :position_builder_at_end, :LLVMPositionBuilderAtEnd, [:pointer, :pointer], :void

  # @method get_insert_block(builder)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @return [FFI::Pointer of BasicBlockRef] 
  # @scope class
  attach_function :get_insert_block, :LLVMGetInsertBlock, [:pointer], :pointer

  # @method clear_insertion_position(builder)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @return [nil] 
  # @scope class
  attach_function :clear_insertion_position, :LLVMClearInsertionPosition, [:pointer], :void

  # @method insert_into_builder(builder, instr)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @param [FFI::Pointer of ValueRef] instr 
  # @return [nil] 
  # @scope class
  attach_function :insert_into_builder, :LLVMInsertIntoBuilder, [:pointer, :pointer], :void

  # @method insert_into_builder_with_name(builder, instr, name)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @param [FFI::Pointer of ValueRef] instr 
  # @param [String] name 
  # @return [nil] 
  # @scope class
  attach_function :insert_into_builder_with_name, :LLVMInsertIntoBuilderWithName, [:pointer, :pointer, :string], :void

  # @method dispose_builder(builder)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @return [nil] 
  # @scope class
  attach_function :dispose_builder, :LLVMDisposeBuilder, [:pointer], :void

  # Metadata
  # 
  # @method set_current_debug_location(builder, l)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @param [FFI::Pointer of ValueRef] l 
  # @return [nil] 
  # @scope class
  attach_function :set_current_debug_location, :LLVMSetCurrentDebugLocation, [:pointer, :pointer], :void

  # @method get_current_debug_location(builder)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :get_current_debug_location, :LLVMGetCurrentDebugLocation, [:pointer], :pointer

  # @method set_inst_debug_location(builder, inst)
  # @param [FFI::Pointer of BuilderRef] builder 
  # @param [FFI::Pointer of ValueRef] inst 
  # @return [nil] 
  # @scope class
  attach_function :set_inst_debug_location, :LLVMSetInstDebugLocation, [:pointer, :pointer], :void

  # Terminators
  # 
  # @method build_ret_void(builder_ref)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_ret_void, :LLVMBuildRetVoid, [:pointer], :pointer

  # @method build_ret(builder_ref, v)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] v 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_ret, :LLVMBuildRet, [:pointer, :pointer], :pointer

  # @method build_aggregate_ret(builder_ref, ret_vals, n)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer to ] ret_vals 
  # @param [Integer] n 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_aggregate_ret, :LLVMBuildAggregateRet, [:pointer, :pointer, :uint], :pointer

  # @method build_br(builder_ref, dest)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of BasicBlockRef] dest 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_br, :LLVMBuildBr, [:pointer, :pointer], :pointer

  # @method build_cond_br(builder_ref, if, then, else)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] if 
  # @param [FFI::Pointer of BasicBlockRef] then 
  # @param [FFI::Pointer of BasicBlockRef] else 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_cond_br, :LLVMBuildCondBr, [:pointer, :pointer, :pointer, :pointer], :pointer

  # @method build_switch(builder_ref, v, else, num_cases)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] v 
  # @param [FFI::Pointer of BasicBlockRef] else 
  # @param [Integer] num_cases 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_switch, :LLVMBuildSwitch, [:pointer, :pointer, :pointer, :uint], :pointer

  # @method build_indirect_br(b, addr, num_dests)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [FFI::Pointer of ValueRef] addr 
  # @param [Integer] num_dests 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_indirect_br, :LLVMBuildIndirectBr, [:pointer, :pointer, :uint], :pointer

  # @method build_invoke(builder_ref, fn, args, num_args, then, catch, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [FFI::Pointer to ] args 
  # @param [Integer] num_args 
  # @param [FFI::Pointer of BasicBlockRef] then 
  # @param [FFI::Pointer of BasicBlockRef] catch 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_invoke, :LLVMBuildInvoke, [:pointer, :pointer, :pointer, :uint, :pointer, :pointer, :string], :pointer

  # @method build_landing_pad(b, ty, pers_fn, num_clauses, name)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [FFI::Pointer of ValueRef] pers_fn 
  # @param [Integer] num_clauses 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_landing_pad, :LLVMBuildLandingPad, [:pointer, :pointer, :pointer, :uint, :string], :pointer

  # @method build_resume(b, exn)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [FFI::Pointer of ValueRef] exn 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_resume, :LLVMBuildResume, [:pointer, :pointer], :pointer

  # @method build_unreachable(builder_ref)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_unreachable, :LLVMBuildUnreachable, [:pointer], :pointer

  # Add a case to the switch instruction
  # 
  # @method add_case(switch, on_val, dest)
  # @param [FFI::Pointer of ValueRef] switch 
  # @param [FFI::Pointer of ValueRef] on_val 
  # @param [FFI::Pointer of BasicBlockRef] dest 
  # @return [nil] 
  # @scope class
  attach_function :add_case, :LLVMAddCase, [:pointer, :pointer, :pointer], :void

  # Add a destination to the indirectbr instruction
  # 
  # @method add_destination(indirect_br, dest)
  # @param [FFI::Pointer of ValueRef] indirect_br 
  # @param [FFI::Pointer of BasicBlockRef] dest 
  # @return [nil] 
  # @scope class
  attach_function :add_destination, :LLVMAddDestination, [:pointer, :pointer], :void

  # Add a catch or filter clause to the landingpad instruction
  # 
  # @method add_clause(landing_pad, clause_val)
  # @param [FFI::Pointer of ValueRef] landing_pad 
  # @param [FFI::Pointer of ValueRef] clause_val 
  # @return [nil] 
  # @scope class
  attach_function :add_clause, :LLVMAddClause, [:pointer, :pointer], :void

  # Set the 'cleanup' flag in the landingpad instruction
  # 
  # @method set_cleanup(landing_pad, val)
  # @param [FFI::Pointer of ValueRef] landing_pad 
  # @param [Integer] val 
  # @return [nil] 
  # @scope class
  attach_function :set_cleanup, :LLVMSetCleanup, [:pointer, :int], :void

  # Arithmetic
  # 
  # @method build_add(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_add, :LLVMBuildAdd, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_nsw_add(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_nsw_add, :LLVMBuildNSWAdd, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_nuw_add(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_nuw_add, :LLVMBuildNUWAdd, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_f_add(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_f_add, :LLVMBuildFAdd, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_sub(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_sub, :LLVMBuildSub, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_nsw_sub(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_nsw_sub, :LLVMBuildNSWSub, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_nuw_sub(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_nuw_sub, :LLVMBuildNUWSub, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_f_sub(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_f_sub, :LLVMBuildFSub, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_mul(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_mul, :LLVMBuildMul, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_nsw_mul(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_nsw_mul, :LLVMBuildNSWMul, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_nuw_mul(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_nuw_mul, :LLVMBuildNUWMul, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_f_mul(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_f_mul, :LLVMBuildFMul, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_u_div(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_u_div, :LLVMBuildUDiv, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_s_div(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_s_div, :LLVMBuildSDiv, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_exact_s_div(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_exact_s_div, :LLVMBuildExactSDiv, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_f_div(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_f_div, :LLVMBuildFDiv, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_u_rem(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_u_rem, :LLVMBuildURem, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_s_rem(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_s_rem, :LLVMBuildSRem, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_f_rem(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_f_rem, :LLVMBuildFRem, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_shl(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_shl, :LLVMBuildShl, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_l_shr(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_l_shr, :LLVMBuildLShr, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_a_shr(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_a_shr, :LLVMBuildAShr, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_and(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_and, :LLVMBuildAnd, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_or(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_or, :LLVMBuildOr, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_xor(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_xor, :LLVMBuildXor, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_bin_op(b, op, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [Symbol from opcode_enum] op 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_bin_op, :LLVMBuildBinOp, [:pointer, :opcode, :pointer, :pointer, :string], :pointer

  # @method build_neg(builder_ref, v, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] v 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_neg, :LLVMBuildNeg, [:pointer, :pointer, :string], :pointer

  # @method build_nsw_neg(b, v, name)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [FFI::Pointer of ValueRef] v 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_nsw_neg, :LLVMBuildNSWNeg, [:pointer, :pointer, :string], :pointer

  # @method build_nuw_neg(b, v, name)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [FFI::Pointer of ValueRef] v 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_nuw_neg, :LLVMBuildNUWNeg, [:pointer, :pointer, :string], :pointer

  # @method build_f_neg(builder_ref, v, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] v 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_f_neg, :LLVMBuildFNeg, [:pointer, :pointer, :string], :pointer

  # @method build_not(builder_ref, v, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] v 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_not, :LLVMBuildNot, [:pointer, :pointer, :string], :pointer

  # Memory
  # 
  # @method build_malloc(builder_ref, ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_malloc, :LLVMBuildMalloc, [:pointer, :pointer, :string], :pointer

  # @method build_array_malloc(builder_ref, ty, val, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_array_malloc, :LLVMBuildArrayMalloc, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_alloca(builder_ref, ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_alloca, :LLVMBuildAlloca, [:pointer, :pointer, :string], :pointer

  # @method build_array_alloca(builder_ref, ty, val, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_array_alloca, :LLVMBuildArrayAlloca, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_free(builder_ref, pointer_val)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] pointer_val 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_free, :LLVMBuildFree, [:pointer, :pointer], :pointer

  # @method build_load(builder_ref, pointer_val, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] pointer_val 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_load, :LLVMBuildLoad, [:pointer, :pointer, :string], :pointer

  # @method build_store(builder_ref, val, ptr)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of ValueRef] ptr 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_store, :LLVMBuildStore, [:pointer, :pointer, :pointer], :pointer

  # @method build_gep(b, pointer, indices, num_indices, name)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [FFI::Pointer of ValueRef] pointer 
  # @param [FFI::Pointer to ] indices 
  # @param [Integer] num_indices 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_gep, :LLVMBuildGEP, [:pointer, :pointer, :pointer, :uint, :string], :pointer

  # @method build_in_bounds_gep(b, pointer, indices, num_indices, name)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [FFI::Pointer of ValueRef] pointer 
  # @param [FFI::Pointer to ] indices 
  # @param [Integer] num_indices 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_in_bounds_gep, :LLVMBuildInBoundsGEP, [:pointer, :pointer, :pointer, :uint, :string], :pointer

  # @method build_struct_gep(b, pointer, idx, name)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [FFI::Pointer of ValueRef] pointer 
  # @param [Integer] idx 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_struct_gep, :LLVMBuildStructGEP, [:pointer, :pointer, :uint, :string], :pointer

  # @method build_global_string(b, str, name)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [String] str 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_global_string, :LLVMBuildGlobalString, [:pointer, :string, :string], :pointer

  # @method build_global_string_ptr(b, str, name)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [String] str 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_global_string_ptr, :LLVMBuildGlobalStringPtr, [:pointer, :string, :string], :pointer

  # Casts
  # 
  # @method build_trunc(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_trunc, :LLVMBuildTrunc, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_z_ext(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_z_ext, :LLVMBuildZExt, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_s_ext(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_s_ext, :LLVMBuildSExt, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_fp_to_ui(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_fp_to_ui, :LLVMBuildFPToUI, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_fp_to_si(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_fp_to_si, :LLVMBuildFPToSI, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_ui_to_fp(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_ui_to_fp, :LLVMBuildUIToFP, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_si_to_fp(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_si_to_fp, :LLVMBuildSIToFP, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_fp_trunc(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_fp_trunc, :LLVMBuildFPTrunc, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_fp_ext(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_fp_ext, :LLVMBuildFPExt, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_ptr_to_int(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_ptr_to_int, :LLVMBuildPtrToInt, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_int_to_ptr(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_int_to_ptr, :LLVMBuildIntToPtr, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_bit_cast(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_bit_cast, :LLVMBuildBitCast, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_z_ext_or_bit_cast(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_z_ext_or_bit_cast, :LLVMBuildZExtOrBitCast, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_s_ext_or_bit_cast(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_s_ext_or_bit_cast, :LLVMBuildSExtOrBitCast, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_trunc_or_bit_cast(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_trunc_or_bit_cast, :LLVMBuildTruncOrBitCast, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_cast(b, op, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] b 
  # @param [Symbol from opcode_enum] op 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_cast, :LLVMBuildCast, [:pointer, :opcode, :pointer, :pointer, :string], :pointer

  # @method build_pointer_cast(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_pointer_cast, :LLVMBuildPointerCast, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_int_cast(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_int_cast, :LLVMBuildIntCast, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_fp_cast(builder_ref, val, dest_ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [FFI::Pointer of TypeRef] dest_ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_fp_cast, :LLVMBuildFPCast, [:pointer, :pointer, :pointer, :string], :pointer

  # Comparisons
  # 
  # @method build_i_cmp(builder_ref, op, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [Symbol from int_predicate_enum] op 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_i_cmp, :LLVMBuildICmp, [:pointer, :int_predicate, :pointer, :pointer, :string], :pointer

  # @method build_f_cmp(builder_ref, op, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [Symbol from real_predicate_enum] op 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_f_cmp, :LLVMBuildFCmp, [:pointer, :real_predicate, :pointer, :pointer, :string], :pointer

  # Miscellaneous instructions
  # 
  # @method build_phi(builder_ref, ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_phi, :LLVMBuildPhi, [:pointer, :pointer, :string], :pointer

  # @method build_call(builder_ref, fn, args, num_args, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] fn 
  # @param [FFI::Pointer to ] args 
  # @param [Integer] num_args 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_call, :LLVMBuildCall, [:pointer, :pointer, :pointer, :uint, :string], :pointer

  # @method build_select(builder_ref, if, then, else, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] if 
  # @param [FFI::Pointer of ValueRef] then 
  # @param [FFI::Pointer of ValueRef] else 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_select, :LLVMBuildSelect, [:pointer, :pointer, :pointer, :pointer, :string], :pointer

  # @method build_va_arg(builder_ref, list, ty, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] list 
  # @param [FFI::Pointer of TypeRef] ty 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_va_arg, :LLVMBuildVAArg, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_extract_element(builder_ref, vec_val, index, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] vec_val 
  # @param [FFI::Pointer of ValueRef] index 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_extract_element, :LLVMBuildExtractElement, [:pointer, :pointer, :pointer, :string], :pointer

  # @method build_insert_element(builder_ref, vec_val, elt_val, index, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] vec_val 
  # @param [FFI::Pointer of ValueRef] elt_val 
  # @param [FFI::Pointer of ValueRef] index 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_insert_element, :LLVMBuildInsertElement, [:pointer, :pointer, :pointer, :pointer, :string], :pointer

  # @method build_shuffle_vector(builder_ref, v1, v2, mask, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] v1 
  # @param [FFI::Pointer of ValueRef] v2 
  # @param [FFI::Pointer of ValueRef] mask 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_shuffle_vector, :LLVMBuildShuffleVector, [:pointer, :pointer, :pointer, :pointer, :string], :pointer

  # @method build_extract_value(builder_ref, agg_val, index, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] agg_val 
  # @param [Integer] index 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_extract_value, :LLVMBuildExtractValue, [:pointer, :pointer, :uint, :string], :pointer

  # @method build_insert_value(builder_ref, agg_val, elt_val, index, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] agg_val 
  # @param [FFI::Pointer of ValueRef] elt_val 
  # @param [Integer] index 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_insert_value, :LLVMBuildInsertValue, [:pointer, :pointer, :pointer, :uint, :string], :pointer

  # @method build_is_null(builder_ref, val, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_is_null, :LLVMBuildIsNull, [:pointer, :pointer, :string], :pointer

  # @method build_is_not_null(builder_ref, val, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] val 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_is_not_null, :LLVMBuildIsNotNull, [:pointer, :pointer, :string], :pointer

  # @method build_ptr_diff(builder_ref, lhs, rhs, name)
  # @param [FFI::Pointer of BuilderRef] builder_ref 
  # @param [FFI::Pointer of ValueRef] lhs 
  # @param [FFI::Pointer of ValueRef] rhs 
  # @param [String] name 
  # @return [FFI::Pointer of ValueRef] 
  # @scope class
  attach_function :build_ptr_diff, :LLVMBuildPtrDiff, [:pointer, :pointer, :pointer, :string], :pointer

  # Changes the type of M so it can be passed to FunctionPassManagers and the
  # JIT.  They take ModuleProviders for historical reasons.
  # 
  # @method create_module_provider_for_existing_module(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [FFI::Pointer of ModuleProviderRef] 
  # @scope class
  attach_function :create_module_provider_for_existing_module, :LLVMCreateModuleProviderForExistingModule, [:pointer], :pointer

  # Destroys the module M.
  # 
  # @method dispose_module_provider(m)
  # @param [FFI::Pointer of ModuleProviderRef] m 
  # @return [nil] 
  # @scope class
  attach_function :dispose_module_provider, :LLVMDisposeModuleProvider, [:pointer], :void

  # ===-- Memory buffers ----------------------------------------------------===
  # 
  # @method create_memory_buffer_with_contents_of_file(path, out_mem_buf, out_message)
  # @param [String] path 
  # @param [FFI::Pointer to ] out_mem_buf 
  # @param [FFI::Pointer to ] out_message 
  # @return [Integer] 
  # @scope class
  attach_function :create_memory_buffer_with_contents_of_file, :LLVMCreateMemoryBufferWithContentsOfFile, [:string, :pointer, :pointer], :int

  # @method create_memory_buffer_with_stdin(out_mem_buf, out_message)
  # @param [FFI::Pointer to ] out_mem_buf 
  # @param [FFI::Pointer to ] out_message 
  # @return [Integer] 
  # @scope class
  attach_function :create_memory_buffer_with_stdin, :LLVMCreateMemoryBufferWithSTDIN, [:pointer, :pointer], :int

  # @method dispose_memory_buffer(mem_buf)
  # @param [FFI::Pointer of MemoryBufferRef] mem_buf 
  # @return [nil] 
  # @scope class
  attach_function :dispose_memory_buffer, :LLVMDisposeMemoryBuffer, [:pointer], :void

  # Return the global pass registry, for use with initialization functions.
  #     See llvm::PassRegistry::getPassRegistry.
  # 
  # @method get_global_pass_registry()
  # @return [FFI::Pointer of PassRegistryRef] 
  # @scope class
  attach_function :get_global_pass_registry, :LLVMGetGlobalPassRegistry, [], :pointer

  # Constructs a new whole-module pass pipeline. This type of pipeline is
  #     suitable for link-time optimization and whole-module transformations.
  #     See llvm::PassManager::PassManager.
  # 
  # @method create_pass_manager()
  # @return [FFI::Pointer of PassManagerRef] 
  # @scope class
  attach_function :create_pass_manager, :LLVMCreatePassManager, [], :pointer

  # Constructs a new function-by-function pass pipeline over the module
  #     provider. It does not take ownership of the module provider. This type of
  #     pipeline is suitable for code generation and JIT compilation tasks.
  #     See llvm::FunctionPassManager::FunctionPassManager.
  # 
  # @method create_function_pass_manager_for_module(m)
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [FFI::Pointer of PassManagerRef] 
  # @scope class
  attach_function :create_function_pass_manager_for_module, :LLVMCreateFunctionPassManagerForModule, [:pointer], :pointer

  # Deprecated: Use LLVMCreateFunctionPassManagerForModule instead.
  # 
  # @method create_function_pass_manager(mp)
  # @param [FFI::Pointer of ModuleProviderRef] mp 
  # @return [FFI::Pointer of PassManagerRef] 
  # @scope class
  attach_function :create_function_pass_manager, :LLVMCreateFunctionPassManager, [:pointer], :pointer

  # Initializes, executes on the provided module, and finalizes all of the
  #     passes scheduled in the pass manager. Returns 1 if any of the passes
  #     modified the module, 0 otherwise. See llvm::PassManager::run(Module&).
  # 
  # @method run_pass_manager(pm, m)
  # @param [FFI::Pointer of PassManagerRef] pm 
  # @param [FFI::Pointer of ModuleRef] m 
  # @return [Integer] 
  # @scope class
  attach_function :run_pass_manager, :LLVMRunPassManager, [:pointer, :pointer], :int

  # Initializes all of the function passes scheduled in the function pass
  #     manager. Returns 1 if any of the passes modified the module, 0 otherwise.
  #     See llvm::FunctionPassManager::doInitialization.
  # 
  # @method initialize_function_pass_manager(fpm)
  # @param [FFI::Pointer of PassManagerRef] fpm 
  # @return [Integer] 
  # @scope class
  attach_function :initialize_function_pass_manager, :LLVMInitializeFunctionPassManager, [:pointer], :int

  # Executes all of the function passes scheduled in the function pass manager
  #     on the provided function. Returns 1 if any of the passes modified the
  #     function, false otherwise.
  #     See llvm::FunctionPassManager::run(Function&).
  # 
  # @method run_function_pass_manager(fpm, f)
  # @param [FFI::Pointer of PassManagerRef] fpm 
  # @param [FFI::Pointer of ValueRef] f 
  # @return [Integer] 
  # @scope class
  attach_function :run_function_pass_manager, :LLVMRunFunctionPassManager, [:pointer, :pointer], :int

  # Finalizes all of the function passes scheduled in in the function pass
  #     manager. Returns 1 if any of the passes modified the module, 0 otherwise.
  #     See llvm::FunctionPassManager::doFinalization.
  # 
  # @method finalize_function_pass_manager(fpm)
  # @param [FFI::Pointer of PassManagerRef] fpm 
  # @return [Integer] 
  # @scope class
  attach_function :finalize_function_pass_manager, :LLVMFinalizeFunctionPassManager, [:pointer], :int

  # Frees the memory of a pass pipeline. For function pipelines, does not free
  #     the module provider.
  #     See llvm::PassManagerBase::~PassManagerBase.
  # 
  # @method dispose_pass_manager(pm)
  # @param [FFI::Pointer of PassManagerRef] pm 
  # @return [nil] 
  # @scope class
  attach_function :dispose_pass_manager, :LLVMDisposePassManager, [:pointer], :void

end